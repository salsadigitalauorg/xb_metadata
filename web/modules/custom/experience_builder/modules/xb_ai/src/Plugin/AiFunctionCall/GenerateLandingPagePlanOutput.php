<?php

namespace Drupal\xb_ai\Plugin\AiFunctionCall;

use Drupal\Core\Plugin\Context\ContextDefinition;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\ai\Attribute\FunctionCall;
use Drupal\ai\Base\FunctionCallBase;
use Drupal\ai\Service\FunctionCalling\ExecutableFunctionCallInterface;
use Drupal\ai\Service\FunctionCalling\FunctionCallInterface;
use Drupal\ai\Utility\ContextDefinitionNormalizer;
use Drupal\ai_agents\PluginInterfaces\AiAgentContextInterface;
use Drupal\xb_ai\XbAiTempStore;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\Yaml\Yaml;

/**
 * Plugin implementation to store LLM-generated landing page plans.
 */
#[FunctionCall(
  id: 'xb_ai:generate_landing_page_plan_output',
  function_name: 'generate_landing_page_plan_output',
  name: 'Generate Landing Page Plan Output',
  description: 'Stores the LLM-generated landing page plan for use by other agents.',
  group: 'planning_tools',
  module_dependencies: ['experience_builder'],
  context_definitions: [
    'plan_structure' => new ContextDefinition(
      data_type: 'string',
      label: new TranslatableMarkup("Plan Structure"),
      description: new TranslatableMarkup("The complete YAML plan structure generated by the LLM UX professional."),
      required: TRUE
    ),
  ],
)]
final class GenerateLandingPagePlanOutput extends FunctionCallBase implements ExecutableFunctionCallInterface, AiAgentContextInterface {

  /**
   * The XB AI tempstore service.
   *
   * @var \Drupal\xb_ai\XbAiTempStore
   */
  protected XbAiTempStore $xbAiTempStore;

  /**
   * The generated plan.
   *
   * @var array
   */
  protected array $generatedPlan = [];

  /**
   * Load from dependency injection container.
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition): FunctionCallInterface | static {
    $instance = new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      new ContextDefinitionNormalizer(),
    );
    $instance->xbAiTempStore = $container->get('xb_ai.tempstore');
    return $instance;
  }

  /**
   * {@inheritdoc}
   */
  public function execute(): void {
    $planStructure = $this->getContextValue('plan_structure');

    try {
      // Parse the LLM-generated YAML plan
      $this->generatedPlan = Yaml::parse($planStructure);

      // Validate the plan structure has required fields
      if (!$this->validatePlanStructure($this->generatedPlan)) {
        throw new \Exception('Invalid plan structure generated by LLM');
      }

      // Add metadata
      $this->generatedPlan['generated_by'] = 'llm_ux_planning_agent';
      $this->generatedPlan['generated_at'] = date('Y-m-d H:i:s');

      // Store the plan in tempstore for use by other agents
      $this->xbAiTempStore->setData(XbAiTempStore::LANDING_PAGE_PLAN_KEY, Yaml::dump($this->generatedPlan, 10, 2));

    } catch (\Exception $e) {
      // If LLM output is malformed, create a basic fallback plan
      $this->createFallbackPlan();
      $this->xbAiTempStore->setData(XbAiTempStore::LANDING_PAGE_PLAN_KEY, Yaml::dump($this->generatedPlan, 10, 2));
    }
  }

 /**
   * Validate that the LLM-generated plan has the required structure.
   *
   * This validation ensures the plan is usable by the builder agent by confirming
   * the presence of essential structural elements and either the professional copy
   * within the 'content' block OR the new 'component_specifications' structure.
   *
   * @param array $plan
   * The plan array to validate.
   *
   * @return bool
   * TRUE if valid, FALSE otherwise.
   */
  private function validatePlanStructure(array $plan): bool {
    return true;
    // 1. Check for essential top-level keys.
    if (!isset($plan['planning_mode'], $plan['milestone_tasks'])) {
      return FALSE;
    }

    // 2. Ensure milestone_tasks is a non-empty array.
    if (!is_array($plan['milestone_tasks']) || empty($plan['milestone_tasks'])) {
      return FALSE;
    }

    // 3. Validate the structure of each milestone task.
    foreach ($plan['milestone_tasks'] as $task) {
      // 3a. Each task MUST have a title.
      if (!isset($task['title'])) {
        return FALSE;
      }

      // 3b. Task must have EITHER content block OR component_specifications.
      $hasContent = isset($task['content']) && is_array($task['content']);
      $hasSpecs = isset($task['component_specifications']) && is_array($task['component_specifications']);

      if (!$hasContent && !$hasSpecs) {
        return FALSE;
      }

      // 3c. If has content block, validate it has meaningful content.
      if ($hasContent && !isset($task['content']['headline']) && !isset($task['content']['body_copy'])) {
        return FALSE;
      }

      // 3d. If has component specifications, validate their structure.
      if ($hasSpecs) {
        foreach ($task['component_specifications'] as $spec) {
          // Must have component_id that looks like an SDC component
          if (!isset($spec['component_id']) || !is_string($spec['component_id'])) {
            return FALSE;
          }

          // Component ID should start with 'sdc.' for SDC components
          if (!str_starts_with($spec['component_id'], 'sdc.')) {
            return FALSE;
          }

          // If props exist, they should be an array
          if (isset($spec['props']) && !is_array($spec['props'])) {
            return FALSE;
          }

          // If slots exist, they should be an array
          if (isset($spec['slots']) && !is_array($spec['slots'])) {
            return FALSE;
          }
        }
      }
    }

    return TRUE;
  }

  /**
   * Create a fallback plan if LLM output is invalid.
   */
  private function createFallbackPlan(): void {
    $this->generatedPlan = [
      'planning_mode' => TRUE,
      'request_complexity' => 'moderate',
      'milestone_tasks' => [
        [
          'task_id' => 1,
          'title' => 'Landing Page Content',
          'description' => 'Create main landing page content based on user requirements',
          'components' => ['content_section'],
          'section_type' => 'content',
          'status' => 'pending',
          'estimated_complexity' => 'moderate',
          'created_at' => date('Y-m-d H:i:s'),
        ],
      ],
      'estimated_sections' => 1,
      'suggested_approach' => 'simple_implementation',
      'build_sequence' => [1],
      'total_estimated_components' => 1,
      'generated_by' => 'fallback_system',
      'fallback_reason' => 'LLM output validation failed',
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function getReadableOutput(): string {
    return Yaml::dump($this->generatedPlan, 10, 2);
  }

}
